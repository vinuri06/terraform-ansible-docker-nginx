name: Automated AWS Deployment Pipeline

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read

jobs:
  provision-and-configure:
    name: Provision and Configure Server
    runs-on: ubuntu-latest

    steps:
      # Get the source code from the repository
      - name: Fetch source code
        uses: actions/checkout@v4

      # Authenticate the GitHub runner with AWS
      - name: Authenticate to AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-north-1

      # Install Terraform CLI
      - name: Install Terraform CLI
        uses: hashicorp/setup-terraform@v3

      # Check if Terraform state file already exists
      - name: Check for Terraform state file
        id: check_state
        run: |
          if [ -f terraform.tfstate ]; then
            echo "STATE_EXISTS=true" >> $GITHUB_ENV
          else
            echo "STATE_EXISTS=false" >> $GITHUB_ENV
          fi

      # Initialize Terraform if it's the first deployment
      - name: Initialize Terraform
        if: env.STATE_EXISTS == 'false'
        run: terraform init

      # Apply Terraform to create infrastructure (only first time)
      - name: Apply Terraform (First Deploy)
        if: env.STATE_EXISTS == 'false'
        run: terraform apply -auto-approve

      # Get the EC2 public IP from Terraform output
      - name: Read EC2 Public IP
        id: get_ip
        run: |
          if [ "${{ env.STATE_EXISTS }}" = "true" ]; then
            echo "Using existing Terraform state..."
          else
            echo "New Terraform deployment..."
          fi
          SERVER_IP=$(terraform output -raw server_public_ip)
          echo "SERVER_IP=$SERVER_IP" >> $GITHUB_ENV

      # Cache Terraform state file for future runs
      - name: Cache Terraform State
        uses: actions/cache@v4
        with:
          path: terraform.tfstate
          key: terraform-state-${{ github.ref }}

      # Install Ansible on the runner
      - name: Install Ansible
        run: |
          sudo apt update -y
          sudo apt install -y python3-pip
          pip3 install ansible

      # Create SSH key file and Ansible inventory
      - name: Generate Ansible Inventory
        run: |
          echo "${{ secrets.EC2_SSH_KEY }}" > deploy_key.pem
          chmod 400 deploy_key.pem
          echo "[web]" > inventory.ini
          echo "${{ env.SERVER_IP }} ansible_user=ec2-user ansible_ssh_private_key_file=./deploy_key.pem" >> inventory.ini

      # Run Ansible playbook to update or deploy HTML content
      - name: Execute Ansible Playbook
        env:
          ANSIBLE_HOST_KEY_CHECKING: False
        run: |
          ansible -i inventory.ini web -m wait_for \
            -a "port=22 host=${{ env.SERVER_IP }} timeout=300" \
            --connection=local
          ansible-playbook -i inventory.ini playbook.yml

      # Print the final result
      - name: Post-Deployment Summary
        run: |
          echo "Deployment complete."
          echo "Access your web app at: http://${{ env.SERVER_IP }}"
